/*
Lightroom API Documentation

Lightroom API Documentation, made available through [adobe.io](https://developer.adobe.com). API Change Logs are available [here](https://developer.adobe.com/lightroom/lightroom-api-docs/release-notes/).

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AlbumsApiService AlbumsApi service
type AlbumsApiService service

type ApiAddAssetsToAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	albumId string
	addAssetsToAlbumRequest *AddAssetsToAlbumRequest
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiAddAssetsToAlbumRequest) XAPIKey(xAPIKey string) ApiAddAssetsToAlbumRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiAddAssetsToAlbumRequest) Authorization(authorization string) ApiAddAssetsToAlbumRequest {
	r.authorization = &authorization
	return r
}

// Album asset metadata and information.
func (r ApiAddAssetsToAlbumRequest) AddAssetsToAlbumRequest(addAssetsToAlbumRequest AddAssetsToAlbumRequest) ApiAddAssetsToAlbumRequest {
	r.addAssetsToAlbumRequest = &addAssetsToAlbumRequest
	return r
}

func (r ApiAddAssetsToAlbumRequest) Execute() (*AddAssetsToAlbum201Response, *http.Response, error) {
	return r.ApiService.AddAssetsToAlbumExecute(r)
}

/*
AddAssetsToAlbum Add assets to album

Add many assets to the album. Note that there is no default defined order/position for the asset in the album. A payload may be provided with cover, order, and any other data allowed in the data model. If the asset already exists in the album and the cover field is supplied, then no error is thrown but only the cover update is applied and other entries in the payload are completely ignored. In all other cases trying to add an asset to an album that is already in the album will return an error. Limited to 50 assets per API call. Returns http status 201 if at least one asset was added to the album. If all assets could not be added, http status 403 is returned. Individual error codes are returned for each asset in the response body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @param albumId Identifier of the album.
 @return ApiAddAssetsToAlbumRequest
*/
func (a *AlbumsApiService) AddAssetsToAlbum(ctx context.Context, catalogId string, albumId string) ApiAddAssetsToAlbumRequest {
	return ApiAddAssetsToAlbumRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		albumId: albumId,
	}
}

// Execute executes the request
//  @return AddAssetsToAlbum201Response
func (a *AlbumsApiService) AddAssetsToAlbumExecute(r ApiAddAssetsToAlbumRequest) (*AddAssetsToAlbum201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddAssetsToAlbum201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsApiService.AddAssetsToAlbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/albums/{album_id}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterToString(r.albumId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return localVarReturnValue, nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}
	if r.addAssetsToAlbumRequest == nil {
		return localVarReturnValue, nil, reportError("addAssetsToAlbumRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.addAssetsToAlbumRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvaildRequestGUID
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAssetExternalXmpDevelopSetting403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	albumId string
	createAlbumRequest *CreateAlbumRequest
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiCreateAlbumRequest) XAPIKey(xAPIKey string) ApiCreateAlbumRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiCreateAlbumRequest) Authorization(authorization string) ApiCreateAlbumRequest {
	r.authorization = &authorization
	return r
}

// Initial album metadata and information.
func (r ApiCreateAlbumRequest) CreateAlbumRequest(createAlbumRequest CreateAlbumRequest) ApiCreateAlbumRequest {
	r.createAlbumRequest = &createAlbumRequest
	return r
}

func (r ApiCreateAlbumRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateAlbumExecute(r)
}

/*
CreateAlbum Create album

Create a new album.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @param albumId Client-generated Lightroom unique identifier for the new album.
 @return ApiCreateAlbumRequest
*/
func (a *AlbumsApiService) CreateAlbum(ctx context.Context, catalogId string, albumId string) ApiCreateAlbumRequest {
	return ApiCreateAlbumRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		albumId: albumId,
	}
}

// Execute executes the request
func (a *AlbumsApiService) CreateAlbumExecute(r ApiCreateAlbumRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsApiService.CreateAlbum")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterToString(r.albumId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.createAlbumRequest == nil {
		return nil, reportError("createAlbumRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.createAlbumRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateAlbum400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CreateAlbum403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v CreateAsset415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	albumId string
	childAlbums *string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiDeleteAlbumRequest) XAPIKey(xAPIKey string) ApiDeleteAlbumRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiDeleteAlbumRequest) Authorization(authorization string) ApiDeleteAlbumRequest {
	r.authorization = &authorization
	return r
}

// This parameter when passed with a value, for example: true would delete all the child albums as well of the album specified. The deletion of child albums will be done asynchronously.
func (r ApiDeleteAlbumRequest) ChildAlbums(childAlbums string) ApiDeleteAlbumRequest {
	r.childAlbums = &childAlbums
	return r
}

func (r ApiDeleteAlbumRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAlbumExecute(r)
}

/*
DeleteAlbum Delete album

Delete an existing album. The existing album should be created via the same client app and of subtype project or project_set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @param albumId Identifier for the album.
 @return ApiDeleteAlbumRequest
*/
func (a *AlbumsApiService) DeleteAlbum(ctx context.Context, catalogId string, albumId string) ApiDeleteAlbumRequest {
	return ApiDeleteAlbumRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		albumId: albumId,
	}
}

// Execute executes the request
func (a *AlbumsApiService) DeleteAlbumExecute(r ApiDeleteAlbumRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsApiService.DeleteAlbum")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterToString(r.albumId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	if r.childAlbums != nil {
		localVarQueryParams.Add("child_albums", parameterToString(*r.childAlbums, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v DeleteAlbum400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ReadAlbum403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAlbumsRequest struct {
	ctx context.Context
	ApiService *AlbumsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	subtype *string
	nameAfter *string
	limit *int32
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiGetAlbumsRequest) XAPIKey(xAPIKey string) ApiGetAlbumsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiGetAlbumsRequest) Authorization(authorization string) ApiGetAlbumsRequest {
	r.authorization = &authorization
	return r
}

// Comma-separated list of subtypes to enumerate. Subtype can be one of &#39;project&#39; or &#39;project_set&#39;.
func (r ApiGetAlbumsRequest) Subtype(subtype string) ApiGetAlbumsRequest {
	r.subtype = &subtype
	return r
}

// UTF-8 string representing the name of the album that should precede the current page of results. In other words, the response will contain result with names greater than the &#39;name_after&#39; value using standard string ordering relations.
func (r ApiGetAlbumsRequest) NameAfter(nameAfter string) ApiGetAlbumsRequest {
	r.nameAfter = &nameAfter
	return r
}

// Number of albums to return. Default value is 100. Please note that the response may contain more than &#39;limit&#39; number of albums returned if multiple albums at the &#39;limit&#39; boundary have the same name_after.
func (r ApiGetAlbumsRequest) Limit(limit int32) ApiGetAlbumsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetAlbumsRequest) Execute() (*GetAlbums200Response, *http.Response, error) {
	return r.ApiService.GetAlbumsExecute(r)
}

/*
GetAlbums Retrieve albums

Retrieve a list of existing albums.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @return ApiGetAlbumsRequest
*/
func (a *AlbumsApiService) GetAlbums(ctx context.Context, catalogId string) ApiGetAlbumsRequest {
	return ApiGetAlbumsRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
	}
}

// Execute executes the request
//  @return GetAlbums200Response
func (a *AlbumsApiService) GetAlbumsExecute(r ApiGetAlbumsRequest) (*GetAlbums200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAlbums200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsApiService.GetAlbums")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/albums"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return localVarReturnValue, nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.subtype != nil {
		localVarQueryParams.Add("subtype", parameterToString(*r.subtype, ""))
	}
	if r.nameAfter != nil {
		localVarQueryParams.Add("name_after", parameterToString(*r.nameAfter, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvaildRequestGUID
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAssetExternalXmpDevelopSetting403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v CreateAsset415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAssetsOfAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	albumId string
	capturedBefore *string
	capturedAfter *string
	orderAfter *string
	orderBefore *string
	limit *int32
	hideStackedAssets *bool
	subtype *string
	flag *string
	embed *string
	exclude *string
	assetIds *string
	albumFilters *string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiListAssetsOfAlbumRequest) XAPIKey(xAPIKey string) ApiListAssetsOfAlbumRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiListAssetsOfAlbumRequest) Authorization(authorization string) ApiListAssetsOfAlbumRequest {
	r.authorization = &authorization
	return r
}

// Used to request assets captured before a given time. captured_before will be found in the \&quot;links.next.href\&quot; link. If no links.next is included in a listing response, this is a hint from the server that there are no assets in the catalog with a date captured_before the last asset in the list (the client has reached the \&quot;bottom\&quot; of the list). captured_before may not be used in conjunction with captured_after.
func (r ApiListAssetsOfAlbumRequest) CapturedBefore(capturedBefore string) ApiListAssetsOfAlbumRequest {
	r.capturedBefore = &capturedBefore
	return r
}

// Used to request assets captured after a given time. captured_after will be found in the \&quot;links.prev.href\&quot; link. If no links.prev is included in a listing response, this is a hint from the server that there are no assets in the catalog with a date captured_after the first asset in the list (the client has reached the \&quot;top\&quot; of the list). Note: assets imported without a captureDate payload property default to the value \&quot;0000-00-00T00:00:00\&quot;. To list these assets set captured_after to \&quot;-0001-12-31T23:59:59\&quot;. captured_after may not be used in conjunction with captured_before.
func (r ApiListAssetsOfAlbumRequest) CapturedAfter(capturedAfter string) ApiListAssetsOfAlbumRequest {
	r.capturedAfter = &capturedAfter
	return r
}

// Used to request assets having order value greater than specified value. Next and previous pages will be found in the \&quot;links.next.href\&quot; and \&quot;links.prev.href\&quot; links respectively. If next/prev link is missing, it indicates that there is no next/prev page. Some rules about using order_after: 1) Specify \&quot;-\&quot; to get the first page. 2) Can be max of 1024 characters. 3) Should be a lex64 sort order string with characters in the set: [-0-9A-Z_a-z] with sort order in the same sequence as in the set [-0-9A-Z_a-z]. 4) captured_before cannot be used with order_after 5) captured_after can be used only if order_after&#x3D;&#x3D;\&quot;\&quot;
func (r ApiListAssetsOfAlbumRequest) OrderAfter(orderAfter string) ApiListAssetsOfAlbumRequest {
	r.orderAfter = &orderAfter
	return r
}

// Used to request assets having order value lesser than specified value. Next and previous pages will be found in the \&quot;links.next.href\&quot; and \&quot;links.prev.href\&quot; links respectively. If next/prev link is missing, it indicates that there is no next/prev page. Some rules about using order_before: 1) Specify order_before as \&quot;\&quot; and captured_before as a future date to get the first page. 2) Can be max of 1024 characters. 3) Should be a lex64 sort order string with characters in the set: [-0-9A-Z_a-z] with sort order in the same sequence as in the set [-0-9A-Z_a-z]. 4) captured_after cannot be used with order_before 5) captured_before can be used only if order_before&#x3D;&#x3D;\&quot;\&quot;
func (r ApiListAssetsOfAlbumRequest) OrderBefore(orderBefore string) ApiListAssetsOfAlbumRequest {
	r.orderBefore = &orderBefore
	return r
}

// Number of assets to return. Default value is 100. Maximum is 500. Please note that the response may contain more than &#39;limit&#39; number of assets returned if the assets at the &#39;limit&#39; boundary has the same capture_date. For example if there are 5 assets in a catalog and the 3rd, 4th and 5th assets all have the same capture dates the response will contain all 5 assets whether &#39;limit&#39; is 3, 4 or 5.
func (r ApiListAssetsOfAlbumRequest) Limit(limit int32) ApiListAssetsOfAlbumRequest {
	r.limit = &limit
	return r
}

// To show or hide assets inside stacks in the catalog. If hide_stacked_assets is passed as true, assets inside stacks won&#39;t be returned. Default value is false.
func (r ApiListAssetsOfAlbumRequest) HideStackedAssets(hideStackedAssets bool) ApiListAssetsOfAlbumRequest {
	r.hideStackedAssets = &hideStackedAssets
	return r
}

// Semi-colon separated asset subtype values.
func (r ApiListAssetsOfAlbumRequest) Subtype(subtype string) ApiListAssetsOfAlbumRequest {
	r.subtype = &subtype
	return r
}

// Semi-colon separated review flag values used to filter assets returned. Can be combined with subtype filter. Valid values for flags are &#39;pick&#39;, &#39;unflagged&#39; and &#39;reject&#39;. This parameter cannot be used along with album_filters parameter. Default behavior is to display all assets.
func (r ApiListAssetsOfAlbumRequest) Flag(flag string) ApiListAssetsOfAlbumRequest {
	r.flag = &flag
	return r
}

// Semicolon-delimited list of additional data to include. When the list includes \&quot;asset\&quot;, the asset subdocuments contains all the fields. Otherwise, only the id and self href link are returned in the asset subdocuments.
func (r ApiListAssetsOfAlbumRequest) Embed(embed string) ApiListAssetsOfAlbumRequest {
	r.embed = &embed
	return r
}

// Used to request the list for different types of assets excluding incomplete or complete image and video assets. The valid values are \&quot;incomplete\&quot; and \&quot;complete\&quot;. An image or video asset is considered to be complete if its proxy or original upload exists. An asset of subtypes profile, preset, camera_profile or lens_profile is considered complete if its original upload exists.
func (r ApiListAssetsOfAlbumRequest) Exclude(exclude string) ApiListAssetsOfAlbumRequest {
	r.exclude = &exclude
	return r
}

// Set of 1 - 100 comma separated asset_id values. Other parameters can not be used in conjunction with this parameter.
func (r ApiListAssetsOfAlbumRequest) AssetIds(assetIds string) ApiListAssetsOfAlbumRequest {
	r.assetIds = &assetIds
	return r
}

// When album_filters is set to &#39;true&#39;, it filters out all the album assets based on the presentation filters set on the album. With this parameter, rejected assets always get filtered out irrespective of settings in presentation filters. Presentation filters are not applied when any value other than &#39;true&#39; is set for album_filters. Default behavior is to display all assets. This parameter cannot be used along with flag parameter.  no Response: 200 OK
func (r ApiListAssetsOfAlbumRequest) AlbumFilters(albumFilters string) ApiListAssetsOfAlbumRequest {
	r.albumFilters = &albumFilters
	return r
}

func (r ApiListAssetsOfAlbumRequest) Execute() (*ListAssetsOfAlbum200Response, *http.Response, error) {
	return r.ApiService.ListAssetsOfAlbumExecute(r)
}

/*
ListAssetsOfAlbum List assets of an album

Lists assets in an album. The assets in an album are returned sorted on either order if order* parameters are used. The assets in an album are returned sorted on captured date if order* parameters are not used and captured* parameters are used. Please note that the created and updated dates for Album asset documents will be returned as "0000-00-00T00:00:00". Successful response may also return invalid flag in the rendition link for the asset. A rendition becomes invalid when an asset is edited after rendition has been generated. New renditions (only 2560 and fullsize) can be generated via Generate Renditions API. The read xmp/develop link in the response will have the invalid flag as true if asset with SHA256 has been created but external xmp/develop has not been uploaded yet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @param albumId Identifier of the album.
 @return ApiListAssetsOfAlbumRequest
*/
func (a *AlbumsApiService) ListAssetsOfAlbum(ctx context.Context, catalogId string, albumId string) ApiListAssetsOfAlbumRequest {
	return ApiListAssetsOfAlbumRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		albumId: albumId,
	}
}

// Execute executes the request
//  @return ListAssetsOfAlbum200Response
func (a *AlbumsApiService) ListAssetsOfAlbumExecute(r ApiListAssetsOfAlbumRequest) (*ListAssetsOfAlbum200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAssetsOfAlbum200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsApiService.ListAssetsOfAlbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/albums/{album_id}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterToString(r.albumId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return localVarReturnValue, nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.capturedBefore != nil {
		localVarQueryParams.Add("captured_before", parameterToString(*r.capturedBefore, ""))
	}
	if r.capturedAfter != nil {
		localVarQueryParams.Add("captured_after", parameterToString(*r.capturedAfter, ""))
	}
	if r.orderAfter != nil {
		localVarQueryParams.Add("order_after", parameterToString(*r.orderAfter, ""))
	}
	if r.orderBefore != nil {
		localVarQueryParams.Add("order_before", parameterToString(*r.orderBefore, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.hideStackedAssets != nil {
		localVarQueryParams.Add("hide_stacked_assets", parameterToString(*r.hideStackedAssets, ""))
	}
	if r.subtype != nil {
		localVarQueryParams.Add("subtype", parameterToString(*r.subtype, ""))
	}
	if r.flag != nil {
		localVarQueryParams.Add("flag", parameterToString(*r.flag, ""))
	}
	if r.embed != nil {
		localVarQueryParams.Add("embed", parameterToString(*r.embed, ""))
	}
	if r.exclude != nil {
		localVarQueryParams.Add("exclude", parameterToString(*r.exclude, ""))
	}
	if r.assetIds != nil {
		localVarQueryParams.Add("asset_ids", parameterToString(*r.assetIds, ""))
	}
	if r.albumFilters != nil {
		localVarQueryParams.Add("album_filters", parameterToString(*r.albumFilters, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvaildRequestGUID
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ReadAlbum403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	albumId string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiReadAlbumRequest) XAPIKey(xAPIKey string) ApiReadAlbumRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiReadAlbumRequest) Authorization(authorization string) ApiReadAlbumRequest {
	r.authorization = &authorization
	return r
}

func (r ApiReadAlbumRequest) Execute() (*ReadAlbum200Response, *http.Response, error) {
	return r.ApiService.ReadAlbumExecute(r)
}

/*
ReadAlbum Get album

Read a album.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @param albumId Client-generated Lightroom unique identifier for the new album.
 @return ApiReadAlbumRequest
*/
func (a *AlbumsApiService) ReadAlbum(ctx context.Context, catalogId string, albumId string) ApiReadAlbumRequest {
	return ApiReadAlbumRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		albumId: albumId,
	}
}

// Execute executes the request
//  @return ReadAlbum200Response
func (a *AlbumsApiService) ReadAlbumExecute(r ApiReadAlbumRequest) (*ReadAlbum200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReadAlbum200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsApiService.ReadAlbum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterToString(r.albumId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return localVarReturnValue, nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ReadAlbum403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAlbumRequest struct {
	ctx context.Context
	ApiService *AlbumsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	albumId string
	updateAlbumRequest *UpdateAlbumRequest
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiUpdateAlbumRequest) XAPIKey(xAPIKey string) ApiUpdateAlbumRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiUpdateAlbumRequest) Authorization(authorization string) ApiUpdateAlbumRequest {
	r.authorization = &authorization
	return r
}

// Album metadata and information to be updated.
func (r ApiUpdateAlbumRequest) UpdateAlbumRequest(updateAlbumRequest UpdateAlbumRequest) ApiUpdateAlbumRequest {
	r.updateAlbumRequest = &updateAlbumRequest
	return r
}

func (r ApiUpdateAlbumRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateAlbumExecute(r)
}

/*
UpdateAlbum Update album

Update an existing album. The existing album should be created via the same client app and of subtype project or project_set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @param albumId Identifier for the album.
 @return ApiUpdateAlbumRequest
*/
func (a *AlbumsApiService) UpdateAlbum(ctx context.Context, catalogId string, albumId string) ApiUpdateAlbumRequest {
	return ApiUpdateAlbumRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		albumId: albumId,
	}
}

// Execute executes the request
func (a *AlbumsApiService) UpdateAlbumExecute(r ApiUpdateAlbumRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlbumsApiService.UpdateAlbum")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/albums/{album_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"album_id"+"}", url.PathEscape(parameterToString(r.albumId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.updateAlbumRequest == nil {
		return nil, reportError("updateAlbumRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.updateAlbumRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateAlbum400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ReadAlbum403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v CreateAsset415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
