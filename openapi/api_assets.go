/*
Lightroom API Documentation

Lightroom API Documentation, made available through [adobe.io](https://developer.adobe.com). API Change Logs are available [here](https://developer.adobe.com/lightroom/lightroom-api-docs/release-notes/).

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AssetsApiService AssetsApi service
type AssetsApiService service

type ApiCreateAssetRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	assetId string
	createAssetRequest *CreateAssetRequest
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiCreateAssetRequest) XAPIKey(xAPIKey string) ApiCreateAssetRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiCreateAssetRequest) Authorization(authorization string) ApiCreateAssetRequest {
	r.authorization = &authorization
	return r
}

// Initial asset metadata and import information.
func (r ApiCreateAssetRequest) CreateAssetRequest(createAssetRequest CreateAssetRequest) ApiCreateAssetRequest {
	r.createAssetRequest = &createAssetRequest
	return r
}

func (r ApiCreateAssetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateAssetExecute(r)
}

/*
CreateAsset Create asset

Create a new asset with initial metadata and import information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog in which the asset will be created.
 @param assetId Client-generated Lightroom unique identifier for the new asset.
 @return ApiCreateAssetRequest
*/
func (a *AssetsApiService) CreateAsset(ctx context.Context, catalogId string, assetId string) ApiCreateAssetRequest {
	return ApiCreateAssetRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		assetId: assetId,
	}
}

// Execute executes the request
func (a *AssetsApiService) CreateAssetExecute(r ApiCreateAssetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.CreateAsset")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets/{asset_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"asset_id"+"}", url.PathEscape(parameterToString(r.assetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.createAssetRequest == nil {
		return nil, reportError("createAssetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	// body params
	localVarPostBody = r.createAssetRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v CreateAsset400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CreateAsset403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v CreateAsset415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateAssetOriginalRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	authorization *string
	contentType *string
	catalogId string
	assetId string
	contentLength *int32
	contentRange *string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiCreateAssetOriginalRequest) XAPIKey(xAPIKey string) ApiCreateAssetOriginalRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiCreateAssetOriginalRequest) Authorization(authorization string) ApiCreateAssetOriginalRequest {
	r.authorization = &authorization
	return r
}

// Content type. For jpeg assets, the only allowed type is &#39;image/jpeg&#39;. For camera raw assets the type is &#39;application/octet-stream&#39;. For video assets, the content-type is of the format video/_* where * depends upon the video type and can contain only ASCII characters. Or the content-type of video can be application/octet-stream;video
func (r ApiCreateAssetOriginalRequest) ContentType(contentType string) ApiCreateAssetOriginalRequest {
	r.contentType = &contentType
	return r
}

// Length in bytes of the content.
func (r ApiCreateAssetOriginalRequest) ContentLength(contentLength int32) ApiCreateAssetOriginalRequest {
	r.contentLength = &contentLength
	return r
}

// Byte range for the request, including first and last bytes and entity length as defined in RFC 2616. Should be included only when the data cannot be uploaded in a single call.
func (r ApiCreateAssetOriginalRequest) ContentRange(contentRange string) ApiCreateAssetOriginalRequest {
	r.contentRange = &contentRange
	return r
}

func (r ApiCreateAssetOriginalRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateAssetOriginalExecute(r)
}

/*
CreateAssetOriginal Create an asset original file

Create and upload an original file for the asset. Up to 200 MB may be uploaded per invocation, and larger files may be uploaded by calling this API multiple times with Content-Range headers for each part. When all parts are received the upload will be consolidated asynchronously. All partial uploads should include optional rendition type parameters to ensure the last part received has the necessary options for request post-processing.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog in which the asset will be created.
 @param assetId Identifier of the asset to which the XMP settings are associated.
 @return ApiCreateAssetOriginalRequest
*/
func (a *AssetsApiService) CreateAssetOriginal(ctx context.Context, catalogId string, assetId string) ApiCreateAssetOriginalRequest {
	return ApiCreateAssetOriginalRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		assetId: assetId,
	}
}

// Execute executes the request
func (a *AssetsApiService) CreateAssetOriginalExecute(r ApiCreateAssetOriginalRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.CreateAssetOriginal")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets/{asset_id}/master"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"asset_id"+"}", url.PathEscape(parameterToString(r.assetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.contentLength != nil {
		localVarHeaderParams["Content-Length"] = parameterToString(*r.contentLength, "")
	}
	if r.contentRange != nil {
		localVarHeaderParams["Content-Range"] = parameterToString(*r.contentRange, "")
	}
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvaildRequestGUID
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetHealth403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 413 {
			var v CreateAssetOriginal413Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v CreateAsset415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGenerateRenditionsRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	xGenerateRenditions *string
	authorization *string
	catalogId string
	assetId string
	contentLength *int32
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiGenerateRenditionsRequest) XAPIKey(xAPIKey string) ApiGenerateRenditionsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// One or multiple of the supported rendition types separated by &#39;,&#39;. Supported rendition types are : [&#39;fullsize&#39;, &#39;2560&#39;].
func (r ApiGenerateRenditionsRequest) XGenerateRenditions(xGenerateRenditions string) ApiGenerateRenditionsRequest {
	r.xGenerateRenditions = &xGenerateRenditions
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiGenerateRenditionsRequest) Authorization(authorization string) ApiGenerateRenditionsRequest {
	r.authorization = &authorization
	return r
}

// Length in bytes of the content.
func (r ApiGenerateRenditionsRequest) ContentLength(contentLength int32) ApiGenerateRenditionsRequest {
	r.contentLength = &contentLength
	return r
}

func (r ApiGenerateRenditionsRequest) Execute() (*GenerateRenditions202Response, *http.Response, error) {
	return r.ApiService.GenerateRenditionsExecute(r)
}

/*
GenerateRenditions Generate renditions for an original file

Generate renditions for an original file asynchronously. Allowed rendition types are fullsize and 2560. Generated rendition will be deleted after 1 day automatically.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog in which the asset was created.
 @param assetId Identifier of the asset for which rendition gets generated.
 @return ApiGenerateRenditionsRequest
*/
func (a *AssetsApiService) GenerateRenditions(ctx context.Context, catalogId string, assetId string) ApiGenerateRenditionsRequest {
	return ApiGenerateRenditionsRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		assetId: assetId,
	}
}

// Execute executes the request
//  @return GenerateRenditions202Response
func (a *AssetsApiService) GenerateRenditionsExecute(r ApiGenerateRenditionsRequest) (*GenerateRenditions202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GenerateRenditions202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GenerateRenditions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets/{asset_id}/renditions"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"asset_id"+"}", url.PathEscape(parameterToString(r.assetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return localVarReturnValue, nil, reportError("xAPIKey is required and must be specified")
	}
	if r.xGenerateRenditions == nil {
		return localVarReturnValue, nil, reportError("xGenerateRenditions is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["X-Generate-Renditions"] = parameterToString(*r.xGenerateRenditions, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	if r.contentLength != nil {
		localVarHeaderParams["Content-Length"] = parameterToString(*r.contentLength, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GenerateRenditions400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetHealth403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	assetId string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiGetAssetRequest) XAPIKey(xAPIKey string) ApiGetAssetRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiGetAssetRequest) Authorization(authorization string) ApiGetAssetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetAssetRequest) Execute() (*GetAsset200Response, *http.Response, error) {
	return r.ApiService.GetAssetExecute(r)
}

/*
GetAsset Get a catalog asset

Retrieves information about a single asset in a catalog that the caller owns. Successful response may also return invalid flag in the rendition link for the asset. A rendition becomes invalid when an asset is edited after rendition has been generated. New renditions (only 2560 and fullsize) can be generated via Generate Renditions API. The read xmp/develop link in the response will have the invalid flag as true if asset with SHA256 has been created but external xmp/develop has not been uploaded yet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog
 @param assetId Identifier of the asset
 @return ApiGetAssetRequest
*/
func (a *AssetsApiService) GetAsset(ctx context.Context, catalogId string, assetId string) ApiGetAssetRequest {
	return ApiGetAssetRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		assetId: assetId,
	}
}

// Execute executes the request
//  @return GetAsset200Response
func (a *AssetsApiService) GetAssetExecute(r ApiGetAssetRequest) (*GetAsset200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAsset200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GetAsset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets/{asset_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"asset_id"+"}", url.PathEscape(parameterToString(r.assetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return localVarReturnValue, nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAsset400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAsset403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetExternalXmpDevelopSettingRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	assetId string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiGetAssetExternalXmpDevelopSettingRequest) XAPIKey(xAPIKey string) ApiGetAssetExternalXmpDevelopSettingRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiGetAssetExternalXmpDevelopSettingRequest) Authorization(authorization string) ApiGetAssetExternalXmpDevelopSettingRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetAssetExternalXmpDevelopSettingRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAssetExternalXmpDevelopSettingExecute(r)
}

/*
GetAssetExternalXmpDevelopSetting Get latest asset external xmp develop setting

Get latest asset external xmp develop setting file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog in which asset exists.
 @param assetId Identifier of the asset for which to fetch rendition.
 @return ApiGetAssetExternalXmpDevelopSettingRequest
*/
func (a *AssetsApiService) GetAssetExternalXmpDevelopSetting(ctx context.Context, catalogId string, assetId string) ApiGetAssetExternalXmpDevelopSettingRequest {
	return ApiGetAssetExternalXmpDevelopSettingRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		assetId: assetId,
	}
}

// Execute executes the request
func (a *AssetsApiService) GetAssetExternalXmpDevelopSettingExecute(r ApiGetAssetExternalXmpDevelopSettingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GetAssetExternalXmpDevelopSetting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets/{asset_id}/xmp/develop"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"asset_id"+"}", url.PathEscape(parameterToString(r.assetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v InvaildRequestGUID
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAssetExternalXmpDevelopSetting403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAssetRenditionRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	assetId string
	renditionType string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiGetAssetRenditionRequest) XAPIKey(xAPIKey string) ApiGetAssetRenditionRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiGetAssetRenditionRequest) Authorization(authorization string) ApiGetAssetRenditionRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetAssetRenditionRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAssetRenditionExecute(r)
}

/*
GetAssetRendition Get latest asset rendition

Get latest asset rendition of specified type. It returns 404 if rendition does not exist. It returns 404 in another case when rendition is invalid (only for rendition type 2560 and fullsize)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog in which asset exists.
 @param assetId Identifier of the asset for which to fetch rendition.
 @param renditionType One of the supported rendition types. Supported rendition types are : ['thumbnail2x', 'fullsize', '640', '1280', '2048', '2560'].
 @return ApiGetAssetRenditionRequest
*/
func (a *AssetsApiService) GetAssetRendition(ctx context.Context, catalogId string, assetId string, renditionType string) ApiGetAssetRenditionRequest {
	return ApiGetAssetRenditionRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		assetId: assetId,
		renditionType: renditionType,
	}
}

// Execute executes the request
func (a *AssetsApiService) GetAssetRenditionExecute(r ApiGetAssetRenditionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GetAssetRendition")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets{asset_id}/renditions/{rendition_type}"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"asset_id"+"}", url.PathEscape(parameterToString(r.assetId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"rendition_type"+"}", url.PathEscape(parameterToString(r.renditionType, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAssetRendition400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAssetsRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	updatedSince *string
	capturedBefore *string
	capturedAfter *string
	limit *int32
	sha256 *string
	hideStackedAssets *bool
	subtype *string
	assetIds *string
	exclude *string
	group *string
	name *string
	favorite *string
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiGetAssetsRequest) XAPIKey(xAPIKey string) ApiGetAssetsRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiGetAssetsRequest) Authorization(authorization string) ApiGetAssetsRequest {
	r.authorization = &authorization
	return r
}

// Starting timestamp
func (r ApiGetAssetsRequest) UpdatedSince(updatedSince string) ApiGetAssetsRequest {
	r.updatedSince = &updatedSince
	return r
}

// Used to request assets captured before a given time. captured_before will be found in the \&quot;links.next.href\&quot; link. If no links.next is included in a listing response, this is a hint from the server that there are no assets in the catalog with a date captured_before the last asset in the list (the client has reached the \&quot;bottom\&quot; of the list). captured_before may not be used in conjunction with captured_after.
func (r ApiGetAssetsRequest) CapturedBefore(capturedBefore string) ApiGetAssetsRequest {
	r.capturedBefore = &capturedBefore
	return r
}

// Used to request assets captured after a given time. captured_after will be found in the \&quot;links.prev.href\&quot; link. If no links.prev is included in a listing response, this is a hint from the server that there are no assets in the catalog with a date captured_after the first asset in the list (the client has reached the \&quot;top\&quot; of the list). Note: assets imported without a captureDate payload property default to the value \&quot;0000-00-00T00:00:00\&quot;. To list these assets set captured_after to \&quot;-0001-12-31T23:59:59\&quot;. captured_after may not be used in conjunction with captured_before.
func (r ApiGetAssetsRequest) CapturedAfter(capturedAfter string) ApiGetAssetsRequest {
	r.capturedAfter = &capturedAfter
	return r
}

// Number of assets to return. Default value is 100. Maximum is 500. Please note that the response may contain more than &#39;limit&#39; number of assets returned if the assets at the &#39;limit&#39; boundary has the same capture_date. For example if there are 5 assets in a catalog and the 3rd, 4th and 5th assets all have the same capture dates the response will contain all 5 assets whether &#39;limit&#39; is 3, 4 or 5.
func (r ApiGetAssetsRequest) Limit(limit int32) ApiGetAssetsRequest {
	r.limit = &limit
	return r
}

// SHA256 hash value of original file. Assets with a matching SHA256 hash will be returned. May be used in conjunction with subtype.
func (r ApiGetAssetsRequest) Sha256(sha256 string) ApiGetAssetsRequest {
	r.sha256 = &sha256
	return r
}

// To show or hide assets inside stacks in the catalog. If hide_stacked_assets is passed as true, assets inside stacks won&#39;t be returned. Default value is false.
func (r ApiGetAssetsRequest) HideStackedAssets(hideStackedAssets bool) ApiGetAssetsRequest {
	r.hideStackedAssets = &hideStackedAssets
	return r
}

// Semi-colon separated asset subtype values.
func (r ApiGetAssetsRequest) Subtype(subtype string) ApiGetAssetsRequest {
	r.subtype = &subtype
	return r
}

// Set of 1 - 100 comma separated asset_id values. Other parameters can not be used in conjunction with this parameter.
func (r ApiGetAssetsRequest) AssetIds(assetIds string) ApiGetAssetsRequest {
	r.assetIds = &assetIds
	return r
}

// Used to request the list for different types of assets excluding incomplete or complete image and video assets. The valid values are \&quot;incomplete\&quot; and \&quot;complete\&quot;. An image or video asset is considered to be complete if its proxy or original upload exists. An asset of subtypes profile, preset, camera_profile or lens_profile is considered complete if its original upload exists.
func (r ApiGetAssetsRequest) Exclude(exclude string) ApiGetAssetsRequest {
	r.exclude = &exclude
	return r
}

// Semi-colon separated group values. Subtype parameter of \&quot;preset\&quot; or \&quot;profile\&quot; is required when using this parameter.
func (r ApiGetAssetsRequest) Group(group string) ApiGetAssetsRequest {
	r.group = &group
	return r
}

// Semi-colon separated name values. Subtype parameter of \&quot;preset\&quot; or \&quot;profile\&quot; is required when using this parameter.
func (r ApiGetAssetsRequest) Name(name string) ApiGetAssetsRequest {
	r.name = &name
	return r
}

// Favorite status, subtype parameter of \&quot;preset\&quot; is required when using this parameter.
func (r ApiGetAssetsRequest) Favorite(favorite string) ApiGetAssetsRequest {
	r.favorite = &favorite
	return r
}

func (r ApiGetAssetsRequest) Execute() (*GetAssets200Response, *http.Response, error) {
	return r.ApiService.GetAssetsExecute(r)
}

/*
GetAssets Retrieve assets

Retrieve a list of existing assets that caller owns. Successful response may also return invalid flag in the rendition link for the asset. A rendition becomes invalid when an asset is edited after rendition has been generated. New renditions (only 2560 and fullsize) can be generated via Generate Renditions API. The read xmp/develop link in the response will have the invalid flag as true if asset with SHA256 has been created but external xmp/develop has not been uploaded yet.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog containing the album.
 @return ApiGetAssetsRequest
*/
func (a *AssetsApiService) GetAssets(ctx context.Context, catalogId string) ApiGetAssetsRequest {
	return ApiGetAssetsRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
	}
}

// Execute executes the request
//  @return GetAssets200Response
func (a *AssetsApiService) GetAssetsExecute(r ApiGetAssetsRequest) (*GetAssets200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAssets200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.GetAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return localVarReturnValue, nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return localVarReturnValue, nil, reportError("authorization is required and must be specified")
	}

	if r.updatedSince != nil {
		localVarQueryParams.Add("updated_since", parameterToString(*r.updatedSince, ""))
	}
	if r.capturedBefore != nil {
		localVarQueryParams.Add("captured_before", parameterToString(*r.capturedBefore, ""))
	}
	if r.capturedAfter != nil {
		localVarQueryParams.Add("captured_after", parameterToString(*r.capturedAfter, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.sha256 != nil {
		localVarQueryParams.Add("sha256", parameterToString(*r.sha256, ""))
	}
	if r.hideStackedAssets != nil {
		localVarQueryParams.Add("hide_stacked_assets", parameterToString(*r.hideStackedAssets, ""))
	}
	if r.subtype != nil {
		localVarQueryParams.Add("subtype", parameterToString(*r.subtype, ""))
	}
	if r.assetIds != nil {
		localVarQueryParams.Add("asset_ids", parameterToString(*r.assetIds, ""))
	}
	if r.exclude != nil {
		localVarQueryParams.Add("exclude", parameterToString(*r.exclude, ""))
	}
	if r.group != nil {
		localVarQueryParams.Add("group", parameterToString(*r.group, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.favorite != nil {
		localVarQueryParams.Add("favorite", parameterToString(*r.favorite, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetAsset400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAsset403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAssetExternalXmpDevelopSettingRequest struct {
	ctx context.Context
	ApiService *AssetsApiService
	xAPIKey *string
	authorization *string
	catalogId string
	contentLength *int32
	contentType *string
	assetId string
	putAssetExternalXmpDevelopSettingRequest *PutAssetExternalXmpDevelopSettingRequest
}

// Client ID (API Key) which is subscribed to the Lightroom APIs through console.adobe.io
func (r ApiPutAssetExternalXmpDevelopSettingRequest) XAPIKey(xAPIKey string) ApiPutAssetExternalXmpDevelopSettingRequest {
	r.xAPIKey = &xAPIKey
	return r
}

// Bearer [token] - User access token of an authenticated Lightroom customer
func (r ApiPutAssetExternalXmpDevelopSettingRequest) Authorization(authorization string) ApiPutAssetExternalXmpDevelopSettingRequest {
	r.authorization = &authorization
	return r
}

// Content length, in bytes. Current maximum size is 200 Mb.
func (r ApiPutAssetExternalXmpDevelopSettingRequest) ContentLength(contentLength int32) ApiPutAssetExternalXmpDevelopSettingRequest {
	r.contentLength = &contentLength
	return r
}

// For uploading a new xmp/develop file content-type&#x3D;&#39;application/rdf+xml&#39; and for copying xmp/develop file from another asset content-type&#x3D;&#39;application/json&#39;
func (r ApiPutAssetExternalXmpDevelopSettingRequest) ContentType(contentType string) ApiPutAssetExternalXmpDevelopSettingRequest {
	r.contentType = &contentType
	return r
}

// The below request body example is for copying external xmp/develop file from another asset. (For upload external xmp/develop  case the body will be a xml string. Eg. &#39;\\&lt;xml.../xml\\&gt;&#39;)
func (r ApiPutAssetExternalXmpDevelopSettingRequest) PutAssetExternalXmpDevelopSettingRequest(putAssetExternalXmpDevelopSettingRequest PutAssetExternalXmpDevelopSettingRequest) ApiPutAssetExternalXmpDevelopSettingRequest {
	r.putAssetExternalXmpDevelopSettingRequest = &putAssetExternalXmpDevelopSettingRequest
	return r
}

func (r ApiPutAssetExternalXmpDevelopSettingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutAssetExternalXmpDevelopSettingExecute(r)
}

/*
PutAssetExternalXmpDevelopSetting Create asset external xmp develop setting file

This API support two workflows. The first workflow is to upload external XMP develop settings file for the asset. Content-type header for this case is application/rdf+xml. The second workflow is to create an external XMP develop settings file by copying from another asset's external xmp develop setting file. Content-type header for this case is application/json.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param catalogId Identifier of the catalog in which the asset will be created.
 @param assetId Client-generated Lightroom unique identifier for the new asset.
 @return ApiPutAssetExternalXmpDevelopSettingRequest
*/
func (a *AssetsApiService) PutAssetExternalXmpDevelopSetting(ctx context.Context, catalogId string, assetId string) ApiPutAssetExternalXmpDevelopSettingRequest {
	return ApiPutAssetExternalXmpDevelopSettingRequest{
		ApiService: a,
		ctx: ctx,
		catalogId: catalogId,
		assetId: assetId,
	}
}

// Execute executes the request
func (a *AssetsApiService) PutAssetExternalXmpDevelopSettingExecute(r ApiPutAssetExternalXmpDevelopSettingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetsApiService.PutAssetExternalXmpDevelopSetting")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/catalogs/{catalog_id}/assets/{asset_id}/xmp/develop"
	localVarPath = strings.Replace(localVarPath, "{"+"catalog_id"+"}", url.PathEscape(parameterToString(r.catalogId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"asset_id"+"}", url.PathEscape(parameterToString(r.assetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAPIKey == nil {
		return nil, reportError("xAPIKey is required and must be specified")
	}
	if r.authorization == nil {
		return nil, reportError("authorization is required and must be specified")
	}
	if r.contentLength == nil {
		return nil, reportError("contentLength is required and must be specified")
	}
	if r.contentType == nil {
		return nil, reportError("contentType is required and must be specified")
	}
	if r.putAssetExternalXmpDevelopSettingRequest == nil {
		return nil, reportError("putAssetExternalXmpDevelopSettingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["X-API-Key"] = parameterToString(*r.xAPIKey, "")
	localVarHeaderParams["Authorization"] = parameterToString(*r.authorization, "")
	localVarHeaderParams["Content-Length"] = parameterToString(*r.contentLength, "")
	localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	// body params
	localVarPostBody = r.putAssetExternalXmpDevelopSettingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v PutAssetExternalXmpDevelopSetting400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CreateAsset403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v CreateAsset415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v GetHealth503Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
